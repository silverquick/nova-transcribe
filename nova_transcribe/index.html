<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nova 2 Sonic – Real-time Transcription (English)</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b0f17;
      --bg-elev: #0f172a;
      --panel: #0f172a;
      --panel-2: #0b1220;
      --border: #243244;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --muted-2: #6b7280;
      --code-bg: #111827;
      --btn-bg: #111827;
      --btn-hover: #1f2937;
      --btn-border: #2b3648;
      --shadow: 0 1px 0 rgba(0,0,0,0.25);
    }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 20px; background: var(--bg); color: var(--text); }
    h1 { margin: 0 0 6px 0; font-size: 20px; color: var(--text); }
    .sub { color: var(--muted); margin-bottom: 14px; }
    .controls { display: flex; gap: 10px; flex-wrap: wrap; margin: 14px 0; align-items: center; }
    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
      font-size: 12px;
      color: var(--muted);
    }
    .toggle input { position: absolute; opacity: 0; width: 0; height: 0; }
    .toggle-slider {
      width: 36px;
      height: 20px;
      border-radius: 999px;
      background: #374151;
      border: 1px solid var(--btn-border);
      position: relative;
      transition: background 0.2s ease;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.15);
    }
    .toggle-slider::after {
      content: "";
      width: 14px;
      height: 14px;
      border-radius: 999px;
      background: #e5e7eb;
      position: absolute;
      top: 2px;
      left: 2px;
      transition: transform 0.2s ease;
      box-shadow: 0 1px 2px rgba(0,0,0,0.4);
    }
    .toggle input:checked + .toggle-slider { background: #22c55e; }
    .toggle input:checked + .toggle-slider::after { transform: translateX(16px); }
    button {
      padding: 10px 14px;
      font-size: 14px;
      cursor: pointer;
      color: var(--text);
      background: var(--btn-bg);
      border: 1px solid var(--btn-border);
      border-radius: 10px;
      box-shadow: var(--shadow);
    }
    button:hover { background: var(--btn-hover); }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    #status { font-size: 13px; color: var(--muted); }
    select {
      padding: 10px 12px;
      font-size: 14px;
      color: var(--text);
      background: var(--btn-bg);
      border: 1px solid var(--btn-border);
      border-radius: 10px;
      box-shadow: var(--shadow);
    }
    select:disabled { opacity: 0.55; }
    option { background: var(--btn-bg); color: var(--text); }
    .sticky-bar {
      position: sticky;
      top: 0;
      z-index: 50;
      background: var(--bg);
      padding: 10px 0;
      border-bottom: 1px solid var(--border);
    }
    .sticky-bar .controls { margin: 0; }
    .sticky-bar .status-indicators { margin: 10px 0 0 0; }
    .status-indicators { display: flex; gap: 12px; margin: 10px 0; font-size: 13px; }
    .indicator { display: flex; align-items: center; gap: 6px; color: var(--muted); }
    .indicator-dot { width: 10px; height: 10px; border-radius: 50%; background: #4b5563; }
    .indicator-dot.active { background: #22c55e; animation: pulse 2s infinite; }
    .indicator-dot.error { background: #ef4444; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    #transcript {
      white-space: pre-wrap;
      min-height: 360px;
      max-height: 500px;
      overflow-y: auto;
      background: var(--panel);
      border: 1px solid var(--border);
      padding: 14px;
      border-radius: 10px;
      font-size: 16px;
      line-height: 1.5;
    }
    #translation {
      white-space: pre-wrap;
      min-height: 360px;
      max-height: 500px;
      overflow-y: auto;
      background: var(--panel-2);
      border: 1px solid var(--border);
      padding: 14px;
      border-radius: 10px;
      font-size: 16px;
      line-height: 1.5;
      margin-top: 12px;
    }
    #pairs {
      min-height: 360px;
      max-height: 500px;
      overflow-y: auto;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      margin-top: 12px;
    }
    .pair {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .pair:hover { background: rgba(255,255,255,0.04); }
    .pair:last-child { border-bottom: 0; }
    .pair-col { white-space: pre-wrap; }
    .pair-col::before { display: none; }
    .pair-en { color: var(--text); }
    .pair-ja { color: #5eead4; }
    @media (max-width: 720px) {
      .pair { grid-template-columns: 1fr; gap: 10px; }
      .pair-col::before {
        display: block;
        content: attr(data-label);
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 0.04em;
        color: var(--muted-2);
        margin-bottom: 6px;
      }
    }
    #catchup {
      background: var(--panel);
      border: 1px solid var(--border);
      padding: 14px;
      border-radius: 10px;
      margin-top: 12px;
      font-size: 14px;
      line-height: 1.5;
    }
    #catchup ul { margin: 8px 0 0 0; padding-left: 18px; }
    .catchup-meta { color: var(--muted); font-size: 12px; }
    .catchup-refs { margin-top: 6px; display: flex; gap: 6px; flex-wrap: wrap; }
    #meeting-assist {
      background: var(--panel-2);
      border: 1px solid var(--border);
      padding: 14px;
      border-radius: 10px;
      margin-top: 12px;
      font-size: 14px;
      line-height: 1.5;
    }
    #meeting-assist ul { margin: 8px 0 0 0; padding-left: 18px; }
    .assist-meta { color: var(--muted); font-size: 12px; }
    .assist-phrase {
      margin-top: 4px;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(34,197,94,0.12);
      color: #a7f3d0;
      font-size: 13px;
      border: 1px solid rgba(34,197,94,0.25);
    }
    .ref-chip {
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(99,102,241,0.14);
      color: #c7d2fe;
      cursor: pointer;
      user-select: none;
    }
    .ref-chip:hover { background: rgba(99,102,241,0.22); }
    .pair.selected { background: rgba(245,158,11,0.14); box-shadow: inset 0 0 0 1px rgba(245,158,11,0.45); }
    .hint { margin-top: 10px; font-size: 12px; color: var(--muted); }
    code { background: var(--code-bg); padding: 1px 4px; border-radius: 4px; color: var(--text); border: 1px solid rgba(255,255,255,0.08); }
  </style>
</head>
<body>
  <h1>Amazon Nova 2 Sonic – Real-time Transcription</h1>
  <div class="sub">Language: <b>English</b> (audio input: 16 kHz, mono, 16-bit PCM)</div>

  <div class="sticky-bar">
    <div class="controls">
      <button id="start">Start</button>
      <button id="stop" disabled>Stop</button>
      <button id="download" disabled>Download TXT</button>
      <button id="clear" disabled>Clear</button>
      <span style="margin-left: 8px; font-size: 12px; color: var(--muted);">Input:</span>
      <select id="input-source">
        <option value="mic" selected>Mic</option>
        <option value="tab">Tab Audio (Chrome/Edge)</option>
      </select>
      <span style="margin-left: 8px; font-size: 12px; color: var(--muted);">Catch up:</span>
      <button id="catchup30" disabled>30s</button>
      <button id="catchup120" disabled>2m</button>
      <button id="catchup300" disabled>5m</button>
      <span style="margin-left: 8px; font-size: 12px; color: var(--muted);">Meeting Assist:</span>
      <label class="toggle">
        <input type="checkbox" id="meeting-assist-toggle" aria-label="Meeting Assist" />
        <span class="toggle-slider"></span>
      </label>
      <div id="status"></div>
    </div>

    <div class="status-indicators">
      <div class="indicator">
        <div class="indicator-dot" id="ws-indicator"></div>
        <span>WebSocket: <span id="ws-status">Disconnected</span></span>
      </div>
      <div class="indicator">
        <div class="indicator-dot" id="audio-indicator"></div>
        <span>Audio: <span id="audio-status">Idle</span></span>
      </div>
      <div class="indicator">
        <div class="indicator-dot" id="aws-indicator"></div>
        <span>AWS: <span id="aws-status">Idle</span></span>
      </div>
      <div class="indicator">
        <div class="indicator-dot" id="translation-indicator"></div>
        <span>Translation: <span id="translation-status">Idle</span></span>
      </div>
      <div class="indicator">
        <div class="indicator-dot" id="catchup-indicator"></div>
        <span>Catch up: <span id="catchup-status">Idle</span></span>
      </div>
      <div class="indicator">
        <div class="indicator-dot" id="meeting-assist-indicator"></div>
        <span>Meeting Assist: <span id="meeting-assist-status">Off</span></span>
      </div>
    </div>
  </div>

  <div id="transcript">Press "Start" and speak.</div>
  <h3>Japanese Translation</h3>
  <div id="translation">…</div>
  <h3>Aligned EN ↔ JA (USER final)</h3>
  <div id="pairs">…</div>
  <h3>Catch up</h3>
  <div id="catchup">Press a button (30s / 2m / 5m) to catch up.</div>
  <h3>Meeting Assist</h3>
  <div id="meeting-assist">Turn on the switch to get live meeting guidance.</div>
  <div class="hint">
    If you deploy behind HTTPS, this page will automatically use <code>wss://</code>. Microphone access requires a secure context (HTTPS or localhost).
    <br>Status indicators show connection health in real-time.
  </div>

<script>
	(() => {
	  let ws = null;
	  let audioContext = null;
      let captureStream = null;
	  let sourceNode = null;
	  let workletNode = null;
	  let legacyProcessor = null;
	  let pingInterval = null;
	  let wakeLock = null;
	  let useAudioWorklet = false;
      let stopping = false;

  let finalText = "";
  let partialText = "";
	  let finalTranslation = "";
	  let partialTranslation = "";
      const alignedPairs = new Map(); // id -> { en, ja, row, enEl, jaEl }

  const TARGET_SR = 16000;
  const FRAME_SAMPLES = 1600; // 100ms at 16kHz

  // リングバッファ：固定サイズで再割り当てを防止
  const RING_BUFFER_SIZE = 8000; // 500ms分のバッファ
  const ringBuffer = new Int16Array(RING_BUFFER_SIZE);
  let ringWriteIndex = 0;
  let ringReadIndex = 0;

  // フレーム送信用の固定バッファ（再割り当て防止）
  const frameBuffer = new ArrayBuffer(FRAME_SAMPLES * 2);
  const frameView = new DataView(frameBuffer);

	  const transcriptDiv = document.getElementById("transcript");
	  const translationDiv = document.getElementById("translation");
      const pairsDiv = document.getElementById("pairs");
	  const statusDiv = document.getElementById("status");
	  const startBtn = document.getElementById("start");
		  const stopBtn = document.getElementById("stop");
		  const downloadBtn = document.getElementById("download");
		  const clearBtn = document.getElementById("clear");
      const catchup30Btn = document.getElementById("catchup30");
      const catchup120Btn = document.getElementById("catchup120");
      const catchup300Btn = document.getElementById("catchup300");
      const catchupDiv = document.getElementById("catchup");
      const meetingAssistToggle = document.getElementById("meeting-assist-toggle");
      const meetingAssistDiv = document.getElementById("meeting-assist");
      const inputSourceSel = document.getElementById("input-source");

  const wsIndicator = document.getElementById("ws-indicator");
  const wsStatus = document.getElementById("ws-status");
  const audioIndicator = document.getElementById("audio-indicator");
	  const audioStatus = document.getElementById("audio-status");
	  const awsIndicator = document.getElementById("aws-indicator");
	  const awsStatus = document.getElementById("aws-status");
      const translationIndicator = document.getElementById("translation-indicator");
      const translationStatus = document.getElementById("translation-status");
      const catchupIndicator = document.getElementById("catchup-indicator");
      const catchupStatus = document.getElementById("catchup-status");
      const meetingAssistIndicator = document.getElementById("meeting-assist-indicator");
      const meetingAssistStatus = document.getElementById("meeting-assist-status");

  function setStatus(msg) { statusDiv.textContent = msg || ""; }

  function updateIndicator(type, status, text) {
	    let indicator, statusSpan;
	    if (type === "ws") { indicator = wsIndicator; statusSpan = wsStatus; }
	    else if (type === "audio") { indicator = audioIndicator; statusSpan = audioStatus; }
	    else if (type === "aws") { indicator = awsIndicator; statusSpan = awsStatus; }
        else if (type === "translation") { indicator = translationIndicator; statusSpan = translationStatus; }
        else if (type === "catchup") { indicator = catchupIndicator; statusSpan = catchupStatus; }
        else if (type === "meeting_assist") { indicator = meetingAssistIndicator; statusSpan = meetingAssistStatus; }
        else { return; }

	    indicator.className = "indicator-dot " + status;
	    statusSpan.textContent = text;
	  }

  function updateView() {
    const merged = finalText + (partialText ? (finalText ? "\n" : "") + partialText : "");
    transcriptDiv.textContent = merged || "…";
    transcriptDiv.scrollTop = transcriptDiv.scrollHeight;
  }

	  function updateTranslationView() {
	    translationDiv.textContent = finalTranslation || "…";
	    translationDiv.scrollTop = translationDiv.scrollHeight;
	  }

      function normalizeText(text) {
        if (!text) return "";
        return text
          .replace(/\\r\\n/g, "\n")
          .replace(/\\n/g, "\n")
          .replace(/\\t/g, "\t");
      }

      function rebuildTranslationFromPairs() {
        const lines = [];
        for (const item of alignedPairs.values()) {
          if (item.ja) lines.push(normalizeText(item.ja));
        }
        finalTranslation = lines.join("\\n");
        partialTranslation = "";
        updateTranslationView();
      }

      function addAlignedPair(id, en) {
        if (!id) return;
        if (alignedPairs.has(id)) return;
        if (pairsDiv.textContent === "…") pairsDiv.textContent = "";

        const row = document.createElement("div");
        row.className = "pair";
        row.dataset.id = id;

        const enEl = document.createElement("div");
        enEl.className = "pair-col pair-en";
        enEl.dataset.label = "EN";
        const enText = normalizeText(en || "");
        enEl.textContent = enText;

        const jaEl = document.createElement("div");
        jaEl.className = "pair-col pair-ja";
        jaEl.dataset.label = "JA";
        jaEl.textContent = "…";

        row.appendChild(enEl);
        row.appendChild(jaEl);
        pairsDiv.appendChild(row);

        alignedPairs.set(id, { en: enText, ja: "", row, enEl, jaEl });
        pairsDiv.scrollTop = pairsDiv.scrollHeight;
      }

      function setAlignedJa(id, ja) {
        if (!id) return;
        if (!alignedPairs.has(id)) addAlignedPair(id, "");
        const item = alignedPairs.get(id);
        item.ja = normalizeText(ja || "");
        item.jaEl.textContent = item.ja || "…";
        pairsDiv.scrollTop = pairsDiv.scrollHeight;
        rebuildTranslationFromPairs();
      }

      let selectedPairId = null;
      function highlightPair(id) {
        if (!id) return;
        if (selectedPairId && alignedPairs.has(selectedPairId)) {
          alignedPairs.get(selectedPairId).row.classList.remove("selected");
        }
        selectedPairId = id;
        const item = alignedPairs.get(id);
        if (!item) return;
        item.row.classList.add("selected");
        try { item.row.scrollIntoView({ block: "center", behavior: "smooth" }); } catch {}
        setTimeout(() => {
          if (selectedPairId === id && alignedPairs.has(id)) {
            alignedPairs.get(id).row.classList.remove("selected");
            selectedPairId = null;
          }
        }, 3500);
      }

      function formatDuration(seconds) {
        if (seconds < 60) return `${seconds}s`;
        const m = Math.round(seconds / 60);
        return `${m}m`;
      }

      function renderCatchup(msg) {
        if (!catchupDiv) return;
        catchupDiv.textContent = "";

        const meta = document.createElement("div");
        meta.className = "catchup-meta";
        meta.textContent = `対象: 直近 ${formatDuration(msg.window_seconds || 0)}（参照IDを押すと該当箇所へジャンプ）`;
        catchupDiv.appendChild(meta);

        const ul = document.createElement("ul");

        function addBullet(text, ids) {
          const li = document.createElement("li");
          const t = document.createElement("div");
          t.textContent = text;
          li.appendChild(t);
          if (ids && ids.length) {
            const refs = document.createElement("div");
            refs.className = "catchup-refs";
            for (const id of ids) {
              const chip = document.createElement("span");
              chip.className = "ref-chip";
              chip.textContent = id;
              chip.onclick = () => highlightPair(id);
              refs.appendChild(chip);
            }
            li.appendChild(refs);
          }
          return li;
        }

        const topic = (msg.topic || "").trim();
        ul.appendChild(addBullet(`今の話題: ${topic || "（不明）"}`, []));

        const important = Array.isArray(msg.important_points) ? msg.important_points : [];
        if (important.length) {
          const li = document.createElement("li");
          li.appendChild(document.createTextNode("重要点:"));
          const sub = document.createElement("ul");
          for (const p of important) {
            sub.appendChild(addBullet(p.text || "", p.ids || []));
          }
          li.appendChild(sub);
          ul.appendChild(li);
        } else {
          ul.appendChild(addBullet("重要点: （なし）", []));
        }

        const decisions = Array.isArray(msg.decisions) ? msg.decisions : [];
        if (decisions.length) {
          const li = document.createElement("li");
          li.appendChild(document.createTextNode("決定事項:"));
          const sub = document.createElement("ul");
          for (const d of decisions) {
            sub.appendChild(addBullet(d.text || "", d.ids || []));
          }
          li.appendChild(sub);
          ul.appendChild(li);
        } else {
          ul.appendChild(addBullet("決定事項: （なし）", []));
        }

        const nextTopic = (msg.next_topic || "").trim();
        ul.appendChild(addBullet(`次の話題: ${nextTopic || "（不明）"}`, []));

        catchupDiv.appendChild(ul);
      }

      function renderMeetingAssist(msg) {
        if (!meetingAssistDiv) return;
        meetingAssistDiv.textContent = "";

        const meta = document.createElement("div");
        meta.className = "assist-meta";
        meta.textContent = `対象: 直近 ${formatDuration(msg.window_seconds || 0)}`;
        meetingAssistDiv.appendChild(meta);

        const ul = document.createElement("ul");

        function addBullet(text) {
          const li = document.createElement("li");
          li.textContent = text;
          return li;
        }

        function participantText(p) {
          if (!p) return "";
          if (typeof p === "string") return p.trim();
          const name = (p.name || "").trim();
          const role = (p.role || "").trim();
          const notes = (p.notes || "").trim();
          let text = "";
          if (name && role) text = `${name}（${role}）`;
          else text = name || role;
          if (notes) text = text ? `${text} - ${notes}` : notes;
          return text;
        }

        const topic = (msg.topic || "").trim();
        ul.appendChild(addBullet(`今の話題: ${topic || "（不明）"}`));

        const participants = Array.isArray(msg.participants) ? msg.participants : [];
        if (participants.length) {
          const li = document.createElement("li");
          li.appendChild(document.createTextNode("会話者:"));
          const sub = document.createElement("ul");
          let added = 0;
          for (const p of participants) {
            const text = participantText(p);
            if (!text) continue;
            const subLi = document.createElement("li");
            subLi.textContent = text;
            sub.appendChild(subLi);
            added += 1;
          }
          if (!added) {
            li.appendChild(document.createTextNode(" （不明）"));
          } else {
            li.appendChild(sub);
          }
          ul.appendChild(li);
        } else {
          ul.appendChild(addBullet("会話者: （不明）"));
        }

        const direction = (msg.direction || "").trim();
        ul.appendChild(addBullet(`会議の方向性: ${direction || "（不明）"}`));

        const options = Array.isArray(msg.options) ? msg.options : [];
        if (options.length) {
          const li = document.createElement("li");
          li.appendChild(document.createTextNode("選択肢:"));
          const sub = document.createElement("ul");
          let added = 0;
          for (const o of options) {
            let text = "";
            if (typeof o === "string") text = o.trim();
            else if (o && typeof o === "object") text = (o.text || "").trim();
            if (!text) continue;
            const subLi = document.createElement("li");
            subLi.textContent = text;
            sub.appendChild(subLi);
            added += 1;
          }
          if (!added) {
            li.appendChild(document.createTextNode(" （なし）"));
          } else {
            li.appendChild(sub);
          }
          ul.appendChild(li);
        } else {
          ul.appendChild(addBullet("選択肢: （なし）"));
        }

        const advice = Array.isArray(msg.english_advice) ? msg.english_advice : [];
        if (advice.length) {
          const li = document.createElement("li");
          li.appendChild(document.createTextNode("英語での発言アドバイス:"));
          const sub = document.createElement("ul");
          let added = 0;
          for (const a of advice) {
            let ja = "";
            let en = "";
            if (typeof a === "string") {
              ja = a.trim();
            } else if (a && typeof a === "object") {
              ja = (a.ja || "").trim();
              en = (a.en || "").trim();
            }
            if (!ja && !en) continue;
            const subLi = document.createElement("li");
            subLi.appendChild(document.createTextNode(ja || "（提案）"));
            if (en) {
              const phrase = document.createElement("div");
              phrase.className = "assist-phrase";
              phrase.textContent = en;
              subLi.appendChild(phrase);
            }
            sub.appendChild(subLi);
            added += 1;
          }
          if (!added) {
            li.appendChild(document.createTextNode(" （なし）"));
          } else {
            li.appendChild(sub);
          }
          ul.appendChild(li);
        } else {
          ul.appendChild(addBullet("英語での発言アドバイス: （なし）"));
        }

        meetingAssistDiv.appendChild(ul);
      }

      function appendMeetingAssistError() {
        if (!meetingAssistDiv) return;
        const line = document.createElement("div");
        line.className = "assist-meta";
        line.textContent = "Meeting Assist Error: 混雑しています。少し待ってください";
        meetingAssistDiv.appendChild(line);
        meetingAssistDiv.scrollTop = meetingAssistDiv.scrollHeight;
      }

      function requestCatchup(seconds) {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        try {
          catchupDiv.textContent = `Catch up 生成中…（直近 ${formatDuration(seconds)}）`;
          ws.send(JSON.stringify({ type: "catchup", seconds }));
        } catch {}
      }

      function sendMeetingAssistToggle(enabled) {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        try {
          ws.send(JSON.stringify({ type: "meeting_assist_toggle", enabled }));
        } catch {}
      }

	  function appendFinal(text) {
        const normalized = normalizeText(text).trim();
        if (!normalized) return;
        if (finalText) finalText += "\\n";
	    finalText += normalized;
	    partialText = "";
    updateView();
  }

  function setPartial(text) {
    const normalized = normalizeText(text || "").trim();
    partialText = normalized ? normalized : "";
    updateView();
  }

  function appendTranslation(text) {
    finalTranslation += normalizeText(text || "");
    partialTranslation = "";
    updateTranslationView();
  }

  // リングバッファに書き込み
  function ringBufferWrite(samples) {
    for (let i = 0; i < samples.length; i++) {
      ringBuffer[ringWriteIndex] = samples[i];
      ringWriteIndex = (ringWriteIndex + 1) % RING_BUFFER_SIZE;
      // オーバーフロー時は古いデータを上書き（リアルタイム性優先）
      if (ringWriteIndex === ringReadIndex) {
        ringReadIndex = (ringReadIndex + 1) % RING_BUFFER_SIZE;
      }
    }
  }

  // リングバッファから読み出し可能なサンプル数
  function ringBufferAvailable() {
    if (ringWriteIndex >= ringReadIndex) {
      return ringWriteIndex - ringReadIndex;
    }
    return RING_BUFFER_SIZE - ringReadIndex + ringWriteIndex;
  }

  // リングバッファからフレームを送信（コピーなしでDataViewに直接書き込み）
  function flushFrames() {
    while (ringBufferAvailable() >= FRAME_SAMPLES) {
      for (let i = 0; i < FRAME_SAMPLES; i++) {
        frameView.setInt16(i * 2, ringBuffer[ringReadIndex], true);
        ringReadIndex = (ringReadIndex + 1) % RING_BUFFER_SIZE;
      }
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(frameBuffer);
      }
    }
  }

  // Float32 -> Int16LE 変換（最適化版：事前確保配列使用）
  function toInt16LEOptimized(float32Array, outputArray) {
    const len = float32Array.length;
    for (let i = 0; i < len; i++) {
      let s = float32Array[i];
      s = s < -1 ? -1 : (s > 1 ? 1 : s);
      outputArray[i] = s < 0 ? (s * 0x8000) | 0 : (s * 0x7FFF) | 0;
    }
    return len;
  }

  // ダウンサンプリング（最適化版）
  function downsampleOptimized(input, inputSampleRate, outputSampleRate, outputArray) {
    if (outputSampleRate === inputSampleRate) {
      for (let i = 0; i < input.length; i++) outputArray[i] = input[i];
      return input.length;
    }
    const ratio = inputSampleRate / outputSampleRate;
    const newLen = Math.round(input.length / ratio);
    let offset = 0;
    for (let i = 0; i < newLen; i++) {
      const nextOffset = Math.round((i + 1) * ratio);
      let acc = 0, count = 0;
      for (let j = offset; j < nextOffset && j < input.length; j++) { acc += input[j]; count++; }
      outputArray[i] = count ? (acc / count) : 0;
      offset = nextOffset;
    }
    return newLen;
  }

  // AudioWorkletプロセッサのコード
  const workletCode = `
    class PCMProcessor extends AudioWorkletProcessor {
      constructor() {
        super();
        this.buffer = new Float32Array(4096);
        this.bufferIndex = 0;
        this.targetSampleRate = 16000;
        this.chunkSize = 1024; // 送信チャンクサイズ
      }

      process(inputs, outputs, parameters) {
        const input = inputs[0];
        if (!input || input.length === 0) return true;

        const channelData = input[0];
        if (!channelData) return true;

        // バッファに追加
        for (let i = 0; i < channelData.length; i++) {
          this.buffer[this.bufferIndex++] = channelData[i];

          // バッファがいっぱいになったらメインスレッドに送信
          if (this.bufferIndex >= this.chunkSize) {
            this.port.postMessage({
              audioData: this.buffer.slice(0, this.bufferIndex),
              sampleRate: sampleRate
            });
            this.bufferIndex = 0;
          }
        }
        return true;
      }
    }
    registerProcessor('pcm-processor', PCMProcessor);
  `;

  // AudioWorkletの初期化
  async function initAudioWorklet(audioCtx, mediaStream) {
    try {
      const blob = new Blob([workletCode], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);
      await audioCtx.audioWorklet.addModule(url);
      URL.revokeObjectURL(url);

      workletNode = new AudioWorkletNode(audioCtx, 'pcm-processor');

      // ワーカー用の一時バッファ（再割り当て防止）
      const tempFloat = new Float32Array(4096);
      const tempInt16 = new Int16Array(4096);

      workletNode.port.onmessage = (e) => {
        const { audioData, sampleRate } = e.data;
        // ダウンサンプリング
        const downLen = downsampleOptimized(audioData, sampleRate, TARGET_SR, tempFloat);
        // Int16変換
        toInt16LEOptimized(tempFloat.subarray(0, downLen), tempInt16);
        // リングバッファに書き込み
        ringBufferWrite(tempInt16.subarray(0, downLen));
        // フレーム送信
        flushFrames();
      };

      sourceNode = audioCtx.createMediaStreamSource(mediaStream);
      sourceNode.connect(workletNode);

      // 一部のブラウザでは destination 接続がないと process() が呼ばれないため、
      // GainNode で無音化して destination に接続（process() の確実な実行を保証）
      const gainNode = audioCtx.createGain();
      gainNode.gain.value = 0; // 無音化
      workletNode.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      useAudioWorklet = true;
      console.log('[Audio] Using AudioWorklet (high performance)');
      return true;
    } catch (err) {
      console.warn('[AudioWorklet] Not available, falling back to ScriptProcessor:', err);
      return false;
    }
  }

  // レガシーScriptProcessorNode（フォールバック）
  function initLegacyProcessor(audioCtx, mediaStream) {
    sourceNode = audioCtx.createMediaStreamSource(mediaStream);
    legacyProcessor = audioCtx.createScriptProcessor(2048, 1, 1);

    // フォールバック用の一時バッファ
    const tempFloat = new Float32Array(4096);
    const tempInt16 = new Int16Array(4096);

    legacyProcessor.onaudioprocess = (e) => {
      const input = e.inputBuffer.getChannelData(0);
      const downLen = downsampleOptimized(input, audioCtx.sampleRate, TARGET_SR, tempFloat);
      toInt16LEOptimized(tempFloat.subarray(0, downLen), tempInt16);
      ringBufferWrite(tempInt16.subarray(0, downLen));
      flushFrames();
    };

    sourceNode.connect(legacyProcessor);
    legacyProcessor.connect(audioCtx.destination);

    useAudioWorklet = false;
    console.log('[Audio] Using ScriptProcessorNode (legacy fallback)');
  }

		  async function start() {
	        stopping = false;
		    // リングバッファをリセット
		    ringWriteIndex = 0;
		    ringReadIndex = 0;
	
	    const scheme = (location.protocol === "https:") ? "wss" : "ws";
	    ws = new WebSocket(`${scheme}://${location.host}/ws`);
	    const wsLocal = ws;
	
		    wsLocal.onopen = async () => {
		      if (ws !== wsLocal) return;
		      setStatus("Connected. Capturing audio…");
		      updateIndicator("ws", "active", "Connected");
	      updateIndicator("audio", "", "Starting...");
	      updateIndicator("aws", "", "Connecting...");
	          updateIndicator("translation", "", "Idle");
	          updateIndicator("catchup", "", "Idle");
              updateIndicator(
                "meeting_assist",
                meetingAssistToggle && meetingAssistToggle.checked ? "active" : "",
                meetingAssistToggle && meetingAssistToggle.checked ? "On" : "Off"
              );
              if (meetingAssistToggle) {
                sendMeetingAssistToggle(!!meetingAssistToggle.checked);
              }

      // Wake Lock
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          console.log('[Wake Lock] Screen wake lock acquired');
          wakeLock.addEventListener('release', () => {
            console.log('[Wake Lock] Screen wake lock released');
          });
        }
      } catch (err) {
        console.warn('[Wake Lock] Failed:', err);
      }

	      // キープアライブ
	      pingInterval = setInterval(() => {
	        if (wsLocal && wsLocal.readyState === WebSocket.OPEN) {
	          wsLocal.send(JSON.stringify({type: "pong"}));
	        }
	      }, 25000);
	    };
	
		    wsLocal.onclose = () => {
		      if (ws !== wsLocal) return;
		      setStatus("Disconnected.");
		      updateIndicator("ws", "", "Disconnected");
	      updateIndicator("audio", "", "Idle");
	      updateIndicator("aws", "", "Idle");
	          updateIndicator("translation", "", "Idle");
	          updateIndicator("catchup", "", "Idle");
              updateIndicator("meeting_assist", "", "Off");
	      if (pingInterval) clearInterval(pingInterval);
	    };
	
		    wsLocal.onerror = () => {
		      if (ws !== wsLocal) return;
	      setStatus("WebSocket error.");
	      updateIndicator("ws", "error", "Error");
	          updateIndicator("translation", "", "Idle");
	          updateIndicator("catchup", "", "Idle");
              updateIndicator("meeting_assist", "", "Off");
	      if (pingInterval) clearInterval(pingInterval);
	    };
	
		    wsLocal.onmessage = (event) => {
		      if (ws !== wsLocal) return;
		      try {
		        const msg = JSON.parse(event.data);
		        if (msg.type === "final") {
		          appendFinal(msg.text);
		        } else if (msg.type === "speculative" || msg.type === "partial") {
	          setPartial(msg.text);
	        } else if (msg.type === "translation") {
	          appendTranslation(msg.text);
            } else if (msg.type === "aligned_en") {
              addAlignedPair(msg.id, msg.en);
            } else if (msg.type === "aligned_ja") {
              setAlignedJa(msg.id, msg.ja);
	            } else if (msg.type === "catchup_result") {
	              renderCatchup(msg);
                  updateIndicator("catchup", "active", "Ready");
	            } else if (msg.type === "meeting_assist_result") {
	              renderMeetingAssist(msg);
                  updateIndicator("meeting_assist", "active", "Ready");
		            } else if (msg.type === "catchup_error") {
		              catchupDiv.textContent = "Catch up Error: " + (msg.error || "Unknown");
                  updateIndicator("catchup", "error", "Error");
		        } else if (msg.type === "meeting_assist_error") {
		          appendMeetingAssistError();
                  updateIndicator("meeting_assist", "error", "Error");
		        } else if (msg.type === "translation_error") {
		          setStatus("Translation Error: " + (msg.error || "Unknown"));
                  updateIndicator("translation", "error", "Error");
		        } else if (msg.type === "info") {
		          setStatus(msg.text);
		        } else if (msg.type === "status") {
	          if (msg.status === "aws_connected") {
	            updateIndicator("aws", "active", "Connected");
	          } else if (msg.status === "aws_error") {
	            updateIndicator("aws", "error", "Error");
	            setStatus("AWS Error: " + (msg.error || "Unknown"));
	          } else if (msg.status === "audio_receiving") {
	            updateIndicator("audio", "active", "Receiving");
	          } else if (msg.status === "transcribing") {
	            updateIndicator("aws", "active", "Transcribing");
              } else if (msg.status === "translation_translating") {
                updateIndicator("translation", "active", "Translating");
              } else if (msg.status === "translation_throttled") {
                updateIndicator("translation", "active", "Throttled");
              } else if (msg.status === "translation_disabled") {
                updateIndicator("translation", "error", "Disabled");
              } else if (msg.status === "translation_idle") {
                updateIndicator("translation", "", "Idle");
              } else if (msg.status === "catchup_generating") {
                updateIndicator("catchup", "active", "Generating");
              } else if (msg.status === "catchup_ready") {
                updateIndicator("catchup", "active", "Ready");
              } else if (msg.status === "catchup_throttled") {
                updateIndicator("catchup", "active", "Throttled");
              } else if (msg.status === "catchup_error") {
                updateIndicator("catchup", "error", "Error");
              } else if (msg.status === "catchup_idle") {
                updateIndicator("catchup", "", "Idle");
              } else if (msg.status === "meeting_assist_enabled") {
                updateIndicator("meeting_assist", "active", "On");
              } else if (msg.status === "meeting_assist_idle") {
                updateIndicator("meeting_assist", "", "Off");
              } else if (msg.status === "meeting_assist_generating") {
                updateIndicator("meeting_assist", "active", "Generating");
              } else if (msg.status === "meeting_assist_ready") {
                updateIndicator("meeting_assist", "active", "Ready");
              } else if (msg.status === "meeting_assist_throttled") {
                updateIndicator("meeting_assist", "active", "Throttled");
              } else if (msg.status === "meeting_assist_error") {
                updateIndicator("meeting_assist", "error", "Error");
		          }
		        } else if (msg.type === "ping") {
		          wsLocal.send(JSON.stringify({type: "pong"}));
		        } else {
		          setPartial(msg.text || "");
	        }
	      } catch (e) {
        appendFinal(event.data);
      }
    };

        const inputSource = (inputSourceSel && inputSourceSel.value) ? inputSourceSel.value : "mic";
        let mediaStream;
        if (inputSource === "tab") {
          if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
            throw new Error("Tab Audio is not supported in this browser. Use Chrome/Edge.");
          }
          setStatus("Select a browser tab and enable 'Share tab audio'…");
          mediaStream = await navigator.mediaDevices.getDisplayMedia({ audio: true, video: true });
          const audioTracks = mediaStream.getAudioTracks();
          if (!audioTracks || audioTracks.length === 0) {
            // Common pitfall: the user shared a window/screen without tab audio.
            mediaStream.getTracks().forEach(t => { try { t.stop(); } catch {} });
            throw new Error("No audio track captured. In the share dialog, choose a TAB and enable 'Share tab audio'.");
          }
        } else {
          mediaStream = await navigator.mediaDevices.getUserMedia({
            audio: { channelCount: 1, echoCancellation: true, noiseSuppression: true, autoGainControl: true }
          });
        }

        captureStream = mediaStream;
        // If the user stops sharing (tab audio), end the session gracefully.
        captureStream.getTracks().forEach((t) => {
          try { t.addEventListener("ended", () => stop()); } catch {}
        });

	    audioContext = new (window.AudioContext || window.webkitAudioContext)();

	    // AudioWorkletを試行、失敗時はScriptProcessorにフォールバック
	    const workletSuccess = await initAudioWorklet(audioContext, mediaStream);
    if (!workletSuccess) {
      initLegacyProcessor(audioContext, mediaStream);
    }

    updateIndicator("audio", "active", "Capturing");

		    startBtn.disabled = true;
		    stopBtn.disabled = false;
		    downloadBtn.disabled = false;
		    clearBtn.disabled = false;
        catchup30Btn.disabled = false;
        catchup120Btn.disabled = false;
        catchup300Btn.disabled = false;
        if (inputSourceSel) inputSourceSel.disabled = true;
		  }

	  function stop() {
        if (stopping) return;
        stopping = true;
	    setStatus("Stopping…");
	    if (ws) { try { ws.close(); } catch {} }
	    ws = null;

	    if (pingInterval) { clearInterval(pingInterval); pingInterval = null; }
    if (workletNode) { try { workletNode.disconnect(); } catch {} }
    if (legacyProcessor) { try { legacyProcessor.disconnect(); } catch {} }
    if (sourceNode) { try { sourceNode.disconnect(); } catch {} }
	    if (audioContext) { try { audioContext.close(); } catch {} }
        if (captureStream) {
          try { captureStream.getTracks().forEach(t => t.stop()); } catch {}
          captureStream = null;
        }

    // Wake Lock解放
    if (wakeLock) {
      try {
        wakeLock.release();
        console.log('[Wake Lock] Released');
      } catch (err) {
        console.warn('[Wake Lock] Failed to release:', err);
      }
      wakeLock = null;
    }

    workletNode = null;
    legacyProcessor = null;
    sourceNode = null;
    audioContext = null;

    // リングバッファをリセット
    ringWriteIndex = 0;
    ringReadIndex = 0;

    updateIndicator("ws", "", "Disconnected");
    updateIndicator("audio", "", "Idle");
    updateIndicator("aws", "", "Idle");

	    startBtn.disabled = false;
	    stopBtn.disabled = true;
        catchup30Btn.disabled = true;
        catchup120Btn.disabled = true;
        catchup300Btn.disabled = true;
        if (inputSourceSel) inputSourceSel.disabled = false;
	  }

  function download() {
    const transcriptContent = (finalText + partialText).trim();
    const translationContent = (finalTranslation + partialTranslation).trim();
    const content = [
      "=== English Transcript ===",
      transcriptContent || "…",
      "",
      "=== Japanese Translation ===",
      translationContent || "…",
      "",
    ].join("\\n");
    const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `transcript_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  }

  function clearAll() {
	    finalText = "";
	    partialText = "";
	    updateView();
	    finalTranslation = "";
	    partialTranslation = "";
	    updateTranslationView();
        alignedPairs.clear();
        if (pairsDiv) pairsDiv.textContent = "…";
        if (catchupDiv) catchupDiv.textContent = "Press a button (30s / 2m / 5m) to catch up.";
        if (meetingAssistDiv) {
          meetingAssistDiv.textContent = (meetingAssistToggle && meetingAssistToggle.checked)
            ? "Meeting Assist is on. Waiting for more conversation..."
            : "Turn on the switch to get live meeting guidance.";
        }
	    if (ws && ws.readyState === WebSocket.OPEN) {
	      try { ws.send(JSON.stringify({type: "clear"})); } catch {}
	    }
	  }

		  startBtn.onclick = () => start().catch(err => {
		    stop();
		    setStatus(String(err));
		    updateIndicator("audio", "error", "Error");
		  });
		  stopBtn.onclick = () => stop();
		  downloadBtn.onclick = () => download();
		  clearBtn.onclick = () => clearAll();
	      catchup30Btn.onclick = () => requestCatchup(30);
	      catchup120Btn.onclick = () => requestCatchup(120);
      catchup300Btn.onclick = () => requestCatchup(300);
      if (meetingAssistToggle) {
        meetingAssistToggle.onchange = () => {
          const enabled = !!meetingAssistToggle.checked;
          updateIndicator("meeting_assist", enabled ? "active" : "", enabled ? "On" : "Off");
          if (meetingAssistDiv) {
            meetingAssistDiv.textContent = enabled
              ? "Meeting Assist を起動しました。会話の流れに応じて更新します。"
              : "Turn on the switch to get live meeting guidance.";
          }
          sendMeetingAssistToggle(enabled);
        };
      }
})();
</script>
</body>
</html>
